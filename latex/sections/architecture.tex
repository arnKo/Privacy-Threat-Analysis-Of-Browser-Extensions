% !TeX spellcheck = en_US

\section{Extension Architecture}

	We have analyzed three different extension architectures to find commonalities and differences: 
	\begin{itemize}
		\itemsep-0.5em
		\item WebExtensions, applicable for Chrome, Opera, and Firefox
		\item Firefox Add-ons
		\item Safari Extensions
	\end{itemize}
	
	In 2009, Google introduced a new extension model for its Chrome browser. 4 years later, the developer of the Opera browser decided to change their browser framework to Chromium \cite{operaBlogSwitchToChromium}. By adapting the same underlying framework as Chrome, Opera also adapted the extension model. It became possible to use the same extension on both browsers. The Mozilla developers recently started to implement their own implementation to support Chrome's extension model in Firefox. Their goal is to establish a general model for extensions which is applicable on all browsers. They orientate themselves on the standardization of web pages. The same extension implementation should work equal on all browsers, similar how the same web page is displayed equal on all browsers. %TODO
	In their development process, the developers named their implementation \textit{WebExtension}. We agreed to adapt their nomenclature in our paper to reefer to this cross-browser extension model. Because the WebExtension support for Firefox is still in development, extensions for Firefox are currently implemented in their old model called \textit{Add-ons}. \\
	%We abstained from analyzing the extension architecture of Internet-Explorer. The browser is out-of-date with the publishing of Windows 10 and their new Browser \textit{Edge} which currently does not support extensions.
	
	\textbf{Development} All extensions are written in web technologies such as JavaScript, HTML and CSS. Therefore, a standard editor can be used to write the extension's source code. 
	
	\begin{table}[h]
		\begin{tabular}{|p{0.3\textwidth}|p{0.3\textwidth}|p{0.3\textwidth}|}\hline
			\textbf{WebExtension} & \textbf{Firefox Add-on} & \textbf{Safari Extension} \\ \hline
			WebExtensions are developed locally as a bundle of JavaScript, HTML, and CSS files. To debug them, the developer can load the bundle in the browser. There is no need for additional software. & 
			Mozilla provides a JavaScript framework to develop Firefox Add-ons. The developer has to install the framework before he starts to implement an Add-on. & 
			Safari provides an user interface to build extensions. The developer can enter needed information directly in the browser and add source code files with a file chooser dialog. \\ \hline
		\end{tabular}
		\caption{Differences in extension development}	
	\end{table}

	\textbf{Structure} Each extension consists of a background and content scripts.
	
	
	For every extension exists mandatory information such as name, version, author, icon, permissions, and other meta-data. They are stored inside special files in the extension bundle. 
	
	\begin{table}[h]
		\begin{tabular}{|p{0.3\textwidth}|p{0.3\textwidth}|p{0.3\textwidth}|}\hline
				\textbf{WebExtension} & \textbf{Firefox Add-on} & \textbf{Safari Extension} \\ \hline
				WebExtensions use a \texttt{JSON} file called \texttt{manifest.json}. & 
				Add-ons also use a \texttt{JSON} file called \texttt{package.json}. & 
				Safari stores the information and settings in \texttt{.plist} files which are filled automatically by Safaris extension builder interface. \\ \hline
			\end{tabular}
		\caption{Differences in extension manifest and settings}
	\end{table}

	\textbf{Extension Background} The extension's main logic is stored inside the extension's background process. It has full access to the browser API and can exchange messages with injected content scripts via a string based message channel.
	
	\begin{table}[h]
		\begin{tabular}{|p{0.3\textwidth}|p{0.3\textwidth}|p{0.3\textwidth}|}\hline
			\textbf{WebExtension} & \textbf{Firefox Add-on} & \textbf{Safari Extension} \\ \hline
			The extensions background is stored inside a single HTML page. JavaScript files with the extension's logic are embedded as script elements in the page.  & 
			& 
			\\ \hline 
		\end{tabular}
		\caption{Differences in the extension's background}
	\end{table}
	
	\textbf{Browser API} The browser provides special functionality to it's extensions such as access to the user's web history and bookmarks, to intercept web requests, and to take screen shots. The extensions background has full access to the API, but content scripts have only access to mandatory modules, for example the communication channel to the background. 
	
	\begin{table}[h]
		\begin{tabular}{|p{0.3\textwidth}|p{0.3\textwidth}|p{0.3\textwidth}|}\hline
			\textbf{WebExtension} & \textbf{Firefox Add-on} & \textbf{Safari Extension} \\ \hline
			The access to the browser API is restricted by permissions. Each API module has a proper permission which needs to be declared in the extension's manifest to get access to the module. Additionally, some permissions throw a warning when the user installs the extension. & 
			& 
			 \\ \hline 
		\end{tabular}
		\caption{Differences in browser API's}
	\end{table}

	\textbf{Content Scripts} To interact with a web page, the extension executes \textit{content scripts} which have full access to the web page's DOM. They behave like JavaScript embedded inside the web page which means they have access to the we page's \texttt{window.document} object. This allows them to manipulate the page's content or change the reaction to user input. Content scripts can not call methods on the extension's core scripts, but only exchange messages with them. \\ 
	The developer can register content scripts for his extension with corresponding URL pattern. The browser compares the pattern with the web pages URL every time a web page is loaded. If they match, the browser will inject the content script in the web page. The developer can use wildcards in the URL pattern to match several web pages at once. For example, a content script with the pattern \texttt{http://*.example.com/*} will be injected into web pages from the domain \texttt{http://api.example.com/} and \texttt{http://www.example.com/foo} but not into the pages from \texttt{https://www.example.com/} and \texttt{http://www.example.org/}. Furthermore, if the developer wants to inject a content script based on additional conditions, he can programmatically inject them himself. \\
	
	\begin{table}[h]
		\begin{tabular}{|p{0.3\textwidth}|p{0.3\textwidth}|p{0.3\textwidth}|}\hline
			\textbf{WebExtension} & \textbf{Firefox Add-on} & \textbf{Safari Extension} \\ \hline
			The developer declares content scripts statically in the extension's manifest. At runtime, the injection of static content scripts can not be prevented. Programmatically injection is also possible, but needs special permissions to access the web page. & 
			Content scripts are dynamically registered in the source code at any time. & 
			Safari supports both static and dynamic registration of content scripts, but not programmatically injection. The extension builder interface provides the functionality to add static content scripts. Safari uses not only a whitelist for its content scripts but also an additional blacklist. \\ \hline 
		\end{tabular}
		\caption{Differences in content scripts}
	\end{table}


	
	The extension models we analyzed have a common base structure. They are implemented in the web technologies JavaScript, HTML and CSS and consists of two parts: The extension's core logic that interacts with the browser and so called \textit{content scripts} that interact with the web page. The extension's core logic is stored inside a single HTML page with embedded JavaScript that implements the behavior. This page is active in the background while the browser is running. It has access to the browser's API that provides additional features such as the access to the browsers tab system or to read the user's bookmarks or web history. Each browser also provides user interfaces to the extension which are mostly buttons in the browser's tool-bars, pop-up HTML pages, or entries in the context menu. \\
	To interact with a web page \textit{content scripts} are executed in the scope of the web pages DOM. They behave like JavaScript which is embedded inside a HTML page, means they have access to the web pages DOM via the \texttt{window.document} object. This allows them to manipulate the DOM tree or change the pages reaction to user input. The injection of content scripts inside a web page is restricted by URL pattern. These are matching pattern that use wildcards to match several web pages at once. For example, a content script with the URL pattern \texttt{http://*.example.com/*} would be injected into the pages \texttt{http://api.example.com/} and \texttt{http://www.example.com/foo} but not into the pages \texttt{https://www.example.com/} and \texttt{http://www.example.org/}. The content script is separated from the extension's core. It can not directly access functions on the extension's core but only exchange messages over a string based channel. It has also almost no access to the browser's API. The range of exposed functions differs between the browsers. \\ 
	A further separation exists between the web page and each injected content script. Each script and the web page runs in its own JavaScript heap with its own DOM object. Consequently, content scripts among each other and the web page can not access each other. Both the web page's script and the content script have access to the variable \texttt{window.document}, but these variables refer to separate JavaScript objects that represent the underlying DOM. If one script now calls a DOM-specific method, such as \texttt{createElement()}, the underlying the DOM and both objects are updated accordingly. However, if a script modifies a non-standard DOM property, such as \texttt{document.bar}, it is not transfered to the DOM and therefore not to the other object, too. The web page and a content script can communicate with each other by using the DOM specific function \texttt{window.postMessage}. The function fires an event which then can be read by an event listener.
	
\subsection{Multi Browser Extensions}
	
	In 2009, Google introduced a new extension model for its Chrome browser. 4 years later, the developer of the Opera browser decided to change their browser framework to Chromium \cite{operaBlogSwitchToChromium}. By adapting the same underlying framework as Chrome, Opera also adapted the extension model. It became possible to use the same extension on both browsers. The Mozilla developers took the chance to expand the utilization of cross browser extensions and integrated Chrome's extension model into Firefox \cite{mozillaBlogWebExtension}. \\
	The model was created accordingly to the proposal from Barth et al. \cite{Barth10protectingbrowsers}. In his work he investigated the old extension model of Mozilla's Firefox and revealed many vulnerabilities in connection to Firefox extensions running with the user's full privileges. This enables the extension to access arbitrary files and launch new processes. He proposed an new model with a strict separation of an extension's content and an permission system that to make it more difficult for an attacker to gain access to the user's machine. \\ 	
	%TODO mention isolated world
	The permission model is designed to limit the danger from benign-but-buggy extensions \cite{Barth10protectingbrowsers}. It is assumed that most extensions are developed by non professional developers who might implement an attack vector by mistake. The permissions should prevent the leak of privileged functions in the case that the extension is compromised. For that purpose the model is built on the principle of least privilege. The access to any API module is disabled by default and only enabled if appropriate permissions are set. The developer should only declare permissions that are necessary for his extension's legitimate purpose. In the case that the extension is compromised the attacker can only use the declared functionality at runtime. Cross-origin access is also restricted by permissions. Although extensions are not bound to the \textit{Same Origin Policy}, Chrome disables requests to remote servers if no appropriate host permission is declared. Equal to content scripts, host permissions take an URL pattern to match several hosts at once. Both type of permissions are declared in the extension's mandatory \textit{manifest} file as seen in Figure 1. Some permissions trigger a warning when a user installs the extension. For example results a host permission in a warning that the extension can read and modify the user's data on the host's web page. Warnings also show up if an extension is updated and its permission's have changed. \\
	
	\lstset{
		numbers=left,
		xleftmargin=2em
	}
%	\lstinputlisting{lib/manifest.json}
	
	Figure 1: Example of a manifest. It shows an extension with two injected scripts and a corresponding host pattern. The extension uses one JavaScript file as its non persistent background page and requests access to two API modules and one cross-origin. Finally, it defines its own Content Security Policy. \\ \\
	
	There are two kinds of background pages: Persistent background pages that are active all the time and non-persistent background pages also called \textit{event pages} that are only active if needed. The browser loads the event page if a task has to be performed and unloads it as soon as the task is finished. This behavior saves memory and resources, consequently giving a better performance. The event page is triggered if the extension is installed or updated so that the background page can register for events, an registered event is dispatched, or an other script accesses the event page. \\
	Both kinds of background page underly a \textit{Content Security Policy (CSP)} \footnote{World Wide Web Consortium CSP2 specification: \url{http://www.w3.org/TR/CSP2/}}. CSP is a web security policy intended to prevent potential content injection attacks. The developer controls the resources the web page loads and executes by listing trusted sources. This is intended as a deeper defense layer to reduce the harm a malicious injection could do, but it is no replacement for a first defense layer such as an input validation or output encoding. The CSP for the extension's background page holds three default rules:
	\begin{itemize}
		\itemsep0em 
		\item JavaScript embedded in the background page with an origin different from the extension's installation is disabled.
		\item Inline JavaScript such as \texttt{<script>} tags or \texttt{onclick="function()"} event handler are disabled.
		\item The use of \texttt{eval} and related functions such as \texttt{setTimeout()} and \texttt{setInterval()} are disabled.
		\footnote{The JavaScript function \textit{eval} is considered dangerous. It executes the given string as a new JavaScript process that has the privileges of the calling process. If the given input can be affected by a third party, it would open a possibility for a content injection attack \cite{mozillaDangerousEval}.}  
	\end{itemize}
	The developer can either relax these policies if his extension needs to use some of the disabled functionality or even tighten them in order to increase the security. Figure 1 shows an example for a CSP. The key \texttt{"default-src 'none'} tightens the policy by disabling resources from any source. Controversial, the second key \texttt{script-src 'self' 'unsafe-eval'} allows to uses script from withing the extension's installation and relaxes the policy by allowing the use of \textit{eval} inside the loaded script. \\
	
	The following list is an extract of the provided API modules with associated permissions and which browser currently supports them. Firefox and Opera are still developing their implementation of the API. The whole lists are found on the developer platforms \cite{chromeDevApiList, operaDevApiList, mozillaDevApiList}. The list is filtered based on modules that provide functionality which can be misused in some form. \\
	
	\begin{tabular}{lp{0.5\textwidth}p{0.26\textwidth}}
		\textbf{Module} & \textbf{Description} & \textbf{Potential Risk} \\ 
		\hline
		
		\textit{activeTab} & Gives the extension temporary access to the active tab only if the user invokes the extension - for example by clicking on a button. This permission is suggested for extensions that otherwise would need full, persistent access to every web page to act if invoked by the user. The activeTab permission grants temporary the \textit{tabs} permission without the need to declare it in the manifest. Not supported by Firefox. &  \\
		
		\textit{background} & If one or more extensions with the background permission are active, the browser runs invisible in the background starting with the user's login. This behavior is only implemented in Chrome and can be disabled generally in Chrome's configuration. & A malicious extension still acts after the browser window is closed. \\
		
		\textit{bookmarks} & Gives read and write access to the user's bookmarks. Only partially supported by Firefox. & Get information about preferred web pages or change the URL of a bookmark to a malicious web page. \\
		
		\textit{contentSettings} &	Allows the extension to overwrite the settings that control whether a web page can use features such as cookies, JavaScript, and plugins for particular web pages. Not supported by Firefox. & Reactivate settings that the user has explicitly deactivated on particular, maybe malicious web pages. For example the location tracking. \\
		
		\textit{cookies} & Gives the extension read and write access to all cookies even to \textit{httpOnly} cookies that are normally invisible to client-side JavaScript. Only partially supported by Firefox. & Steal the users session and authentication data that is mostly stored inside cookies. \\
		
		\textit{downloads} & With this module the extension can initiate, monitor or manipulate downloads. If the file is labeled as dangerous the browser prompts the user to accept the download \cite{chromeMaliciousDownloads}. Not supported by Firefox. &  \\
		
		\textit{geolocation} & Gives the extension access to the HTML geolocation API\footnote{World Wide Web Consortium Geolocation API specification: \url{http://www.w3.org/TR/geolocation-API/}} without prompting the user for permission. Not supported by Firefox and Opera. & Silently track or identify the user. \\
		
		\textit{management} & The extension can list, disable or uninstall other extensions with this module. If an other extension should be uninstalled the user is prompted to accept. Only partially supported by Opera and not supported by Firefox. & Silently disable privacy preserving extensions such as \textit{Adblock} or \textit{NoScript}. \\
		
		\textit{privacy} & The extension can request to change the browser's privacy settings. The request will be denied if an other extension uses the setting or the access is denied by default. Not supported by Firefox. & \\
		
		\textit{proxy} & Allows the extension to manipulate the browser's proxy settings. Not supported by Firefox. & Send user's requests through a malicious proxy like a server that tracks all requests. \\
		
		\textit{system} & Provides information about the user's host machine. Not supported by Firefox. & Create a profile to identify the user based on information such as the kernel or display name. \\
		
		\textit{tabs} & Gives access to the browser's tab system. Allows to create and close tabs, to inject scripts, and to connected to running content scripts inside a tab. Only partially supported by Firefox and Opera. & Prevent the user from uninstalling the extension by closing the extension management tab. Inject other scripts than the declared content scripts, even remote received. \\
		
		\textit{webRequest} & Gives access to events fired by the life cycle of a web request. Allows to observe, intercept or manipulate web requests. Only partially supported by Firefox. & Request data can be read and redirects executed. \\  	 	
		
	\end{tabular}
	
	The activeTab permission and the event pages do not only give a better performance but do also improve the security. If the extension is compromised the attacker would need to wait until the extension is active before obtaining access and would loose the access when the extension is unloaded. On the other hand if the extension itself is malicious it gets restricted in its actions to only act if the user invokes it. \\
	
	Chrome distributes its extensions over the Chrome Web Store\footnote{Chrome Web Store: \url{https://chrome.google.com/webstore/category/extensions}}. The installation of extensions from remote servers was disabled because this mechanism was often misused to install malicious extensions \cite{chromeProtectFromMalicious}. To further restrict the distribution of malicious extensions, Google added a registration fee for developers \cite{chromeWebStoreFee}. The developer has to add a credit card to his Google account. This allows Google to better identify the developer and it discourages possible malicious developers. Opera has its own web store, too \footnote{Opera Web Store: \url{https://addons.opera.com/en/}}. Anyone can commit a new extension which is then reviewed by Opera's developers. The extension is only published if it matches the acceptance criteria. Those range from correct execution over guidelines for adequate design to privacy preserving measures \cite{operaSecurityReviewAcceptance}. Extensions in the multi-browser model are currently not published for Firefox \cite{mozillaWebExtensionStatus}.
	
\subsection{Firefox ADD-ONs}
	
	Mozilla just started implementing the extension model \cite{mozillaBlogWebExtension}. The model is currently not released to Firefox and those extensions are not publicly distributed \cite{mozillaWebExtensionStatus}. Current extensions for Firefox are called \textit{add-ons} and are build with the browsers native technologies. This allows an add-on to use any feature that the browser can use. Mozilla distributed a JavaScript framework for building their add-ons that operates on the modules system defined by the \textit{CommonJS}\footnote{CommonJS Wiki Modules specification: \url{http://wiki.commonjs.org/wiki/Modules/1.1.1}} module format. This allows to resign from the native technologies and focus the development on web technologies. The framework handles the interaction with the native technologies, consequently keeping the access to the browser's features. If an add-on uses those features, it is automatically registered for an extra security review by Mozilla \cite{mozillaDevChromeAuthority}. \\
	The framework uses a \textit{package.json} file that manages the add-on's content similar to the extension's manifest file. Firefox add-ons do not have a permission system comparable to the permissions of the extension model. There is however a \textit{permission} section in the package file. But it only holds three keys: The first indicates whether or not the add-on can access private browsing windows. The second is a list of fully qualified domain names which can be accessed by content scripts. And the third indicates whether or not the add-on is compatible with the multiprocess version of Firefox. \\
	
	The following list shows an extract of the functionality provided to an add-on filtered on possible privacy risks. The full list of modules can be found on Mozilla's developer network \cite{mozillaDevHighLevelApiList, mozillaDevLowLevelApiList} 
	\begin{itemize}
		\item Access Firefox's built-in password manager.
		\item Access users data like bookmarks, favorite web pages, or history.
		\item Read content from URIs and use XMLHttpRequests \cite{w3cXMLHttpRequest}.
		\item Firefox provides a long list of events for which an add-on can register \cite{mozillaDevSystemEvents}.
		\item Read an write environment variables.
		\item Get technical information about the user's host machine.
		\item Access the users file system using the native interfaces.
	\end{itemize}
	
	Firefox uses an internal privilege system to restrict the access of remote JavaScript code. They differentiate between trusted \textit{chrome} code and untrusted \textit{content} code. Chrome code is everything that comes from the browser itself. Its own JavaScript that interacts with the underlying C++ core and add-ons that have access to the browser's API. On the other hand is everything that is loaded from the web classified as content. Objects in a higher privileged scope have full access to other objects in a less privileged scope. But by default they only see the native object without any modifications by the less privileged code. This prevents the higher level code to be tricked with modified functionality by untrusted code. Contrary, less privileged code can not access higher privileged code. In addition to the two main privilege levels, chrome code can generate sandboxes and determines its privilege level and its access to certain objects. Thereby it is possible to give a piece of JavaScript fine grained access to needed functionality without exposing security relevant functions and still protect it from access by less privileged code. For example, content scripts are executed inside a sandbox with certain privileges over content code. Thereby it is protected from direct access by the web page's code and can only see the web page's unmodified DOM. But it has still less privileges than chrome code and can therefore not access the add-on's core or the browser's API. \\
	Firefox uses a security mechanism to prevent an attacker that has compromised an add-on to access submodules that are not explicit requested inside the add-on. On compiling the add-on, a scanner lists all requests to modules inside the add-on's code. The runtime loader will actually prevent the loading of modules that are not listed. This prevents an attacker to use further modules and more privileged functions at runtime. \\
	
	Mozilla distributes add-ons for Firefox over their own web store\footnote{Firefox Web Store: \url{https://addons.mozilla.org/en-US/firefox/}} but also allows the installation from private web pages. Add-ons published over the web store are target to an security review \cite{mozillaDevReviewPolicy}. After passing the review the add-on is signed by Mozilla what is shown on installation. Similarly, if an add-on is published private it is labeled as untrusted on installation. 
	
	%\subsection{Safari Extension}
	%
	%	Safari provides an integrated environment for developing extension. The \textit{Extension Builder} is a build-in user interface where the developer can add files and set properties. The provided API for extensions is limited. It only allows the interaction with browser tabs. There is no support to access user data such as bookmarks or the web history. Safari extensions can only focus on DOM related functionality. \\
	%	The Extension Builder provides a special feature to block content. A list of \textit{Content-Blocking Rules} are compiled into a bytecode format and processed directly at runtime. Making the programmatically examination of content and determination of blocking unnecessary and therefore providing a better performance \cite{safariContentBlockingRules}. \\
	%	Safari's first level security for extension is implemented by certificates. Only registered developers can install a certificate for their extension. Safari disables extensions if the installed certificate is invalid. This should ensure that the extension's origin is known to Apple. It does not prevent the developer to add malicious behavior in his extension.
	