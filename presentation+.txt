What is an extenion? An extension is an additional piece of software that uses the browser's features to enhance the user's interaction with the browser itself and displayed web pages. For that purpose, the browser provides interaces to its extensions that enable an extension to access and manipulate web pages and use browser internal functionality such as bookmarks, the web history, or graphical user interfaces. (Present extensions)
Extensions should not be mistaken with browser plugins. A plugin is an external application installed at the user'S device. The browser loads the plugin on demand which then provides additional features that the browser cannot provide itself. (present plugins)

Browser extensions that harm the user and violate his privacy are already known to researchers and security experts. Such as the as Trojans labeled extensions Febipos and Kilim. Both misuse the user's social media account to distribute spamming content without the user's consent. Modern anti-virus software is configured to detekt and remove them. But there also exists very popular extensions that look harmless at the first sight but provide questionable behavior. As example we present the chrom extension hola which currently has almost 9 million users. it allows the user to bypass regional restrictions on web content. For that purpose, it routes the user's traffic over the devices of other extension users for whom the restrictions do not apply. This creates a VPN-like network that masks the origin of the user's web requests. However, as each extension acts as an end node in the network, the user's IP is regulary exposed to the Internet by requests from other users. Those may include access to illegal content or web attacks. This already creates a threat to the user. However there is more. The company responsible for the extesion provides a second service for paying customers that allows them to route targeted traffic through the network. This was not published to the extension users until the operator of a web platform claims that the network was used to execute DDoS attacks against his servers. Furthermore, security experts that analyzed the extensions after this incident, revealed a bot-net like functionality that allows to remotely control the extensions. This shows that also popular extensions can be misused to harm the user.

With our work we want to demonstrate the threats that emerge from the use of browser extensions and that an extension's functionality allows to execute targeted attacks agains identified users. We focus on an extension architecture used Chrome firefox Edge and Opera which makes our work applicable to the majority of modern browsers. We will first provide an overview of the focused extension architecture. Then we present the results of our general threat analysis. As a proof of concept, we developed a system to integrate malicious behavior into an extension based on already available privileges. To demonstrate the applicability of our implementations, we analyzed existing extensions and show that those already possess the privileges that allow us to integrate our implemented attack vectors. Finally, we present some countermeasures that also affect our system.

Each extension starts with a mandatory manifest file. It declares the extension's meta data such as name, version, and author and its content. The extenion's background consits of a single web page that includes the declared JAvaScript files. It holds the extension's main logic and has access to the browser API that provides additional features such as .... . However, background scripts have no access to displayed web pages. For that purpose, the extension executes content scripts that have access to the DOM of a single web page. URL pattern containing wildcards allow to regulate the web pages in which the content script will be active. Permissins give the extension access to additional functionality. We differenciate between API permissions and host permissions. An API permision gives the extension the access to a corresponding module of the browser's API. The access is denied without the permission. Host permissions regulate the access to web content. An extension is allowed to execute a programatically web request to a remote server only if the server's URL match a declared host permission. Furthermore, host permissions regulate the programatically injection of content scripts. 

The background and content scripts run in their own process on the operating system. This efficienlty separates them beacuse they do not share a common memory section and therefore are not able to invoke functions or access variables of each other. Only a string based message channel allows both sides to communicate. This acts as a security mechanism. In the case that an attacker has sucesfully compormised one part of the extension he can only interact with the other part over the message channel. 
Another security feature that is relevant for our work, is the background page's CSP. A general CSP allows the developer of a web page to regulate the sources from which the web page fetches its resources. TODO



We anylzed the extensions capabilities to find potential threats for the user and his privacy. The biggest threat we found emegerges from the extension unrestricted access to the DOM of a web page. This allows an extension to execute several malicious taks. 
TODO
collect information that the user inserts, commonly web page provides form in which user enters data, transfered to server, we find explicit application on login pages, enters credentials, authenticates against server, if attacker obtains credentials, able to impersonat user,
extension able to collect displayed information, online banking platform, account information, read emails, 
manipulate displayed information, tricking user in false assumptions, adding additional fields to a from, user does not know form, tricks user entering additional and probably sensitive information, able to collect
redirect user to harmful web pages, by manipulating links, duplicates of popular web pages
execute unrestricted web requests, not obvious, JavaScript can execute programatically web requests using XHR interace, inside web page request is restricted by SOP, content script is instead restricted by host permission, even without proper privileges content script can execute web request, 

We identified several permissions and API modules that pose a threat to the user. If one or more extensions with the background permission are active, the browser will start at the operating systen's start and stay active even after its last window was closed. A malicious extension may continue to execute attacks even when no browser window is visible for the user. The cookies module gives access to all currently stored cookies including http-only cookies that are not accessible to the JavaScript of a web page. If an atacker is able to obtain the user's session cookies he can impersonate him at the particular web service. Web pages can use the geolocation API to get the user geographical location. Most browser promt the user if a web page tries to localize him. An extension with the geolocation permission can use the API without prompting the user to accept. The downlaods module allows an extension to monitor, cancel, and initiate user downloads. A malicious extension may initiate the download of a harmful file and exchange an already by the user downloaded file. Furthermore, the downloads dot open permission allows to open downloaded files and the downloads dot shelf permission allows to hide the browser bar that shows active downloads. This may be misued to hidden download and open a harmful file. The management module allows to manage installed extensions including to disable other extensions. The webRequest module provides access to incomming and outgoing web requests. A malicious extension may remove security relevant headers such as a CSP and therefore support other attack vectors. Furthermore an malicious extension is able to intercept and log all requests or redirect request to malicious web pages. The last permission gives access to technical information about the current devices hardware and may be used to identify the current user.

Now we present our design and our implementations that act as our proof of concept for our threat analysis. Our system follows a simple pattern that allows to execute targeted attacks. First, we collect as much pieces of user data as possible and send them to a remote server that is in charge to evaluate the data and identify the current user. If the identification was successfull, we fetch the source code for our attack vectors and execute it. This design brings another advantage than to be able to execute targeted attacks. As long as the identification was no successfull we can fetch harmless scripts instead of our attack vectors and therewith simulate a harmless behavior. This allows us to bypass some detection mechanisms that analyze the source code for known malicious pattern.
Our designed system is able to integrate malicious behavior into existing extensions based on the extensions already requested privileges such as permissions, content scripts, or a modified CSP. To be able to adapt to existing privielges, we designed it as a set of interchangable components that need different privileges and execute different attack vectors. Generally, we divided our system between the collection of user data, coverted communication with a remote server, and explicit attack vectors. 

To identify the extension's current user, we collect as much pieces of information as possible. We follow common approaches such as user tracking and fingerprinting. User tracking is accomplished by storing an unique identifier inside the user's browser and retrieving it on a later occassion. 
We implemented a component that stores a unique identifier in the extension's storage. This storage is persisten and only cleared if the user deinstalls the extension. Unlike for the web page's storage technologies such as cookies or the HTML5 local storage, Chrome, Opera and Firefox do not provide a user interface to clear the extension's storage. The user has to manually delete associated files on his hard drive. Chrome even provide a cloud-based storage which allows us to identify the user on multiple devices. If we use this component after a successful identification, we simplify the identification the next time.
Another common approach for user tracking are so called web beacons. These are content from tracking third partys that are embedded into a web page. IF the content is loaded, all coockies that belong to the origin of the thrid party are send along the request. The thrid party is notified that a particular user has loaded a prticular web page. An example for a web beacon is facebooks like button or similar content from other social media platforms. As an extension can access any web page, we implemented a component that embeds a web beacon. To test our implementation we set up a small server that provides the embedded web beacon and appends a tracking cookie.
Fingerprinting is accomplished by collecting as much pieces of user information as possible from a single visit of a web page. Merging these information creates a fingerprint of the current user and allows to identify him by comparing the current fingerprint to stored ones. Each additional piece of information increases the success rate that the fingerprint is truly unique. JavaScript provides a set of technical information that allow to identify the currently used browser and device. Here we have a list of system depended values that are all accessible through JavaScript.
For our system, we implemented a component that collects the available technical information using JavaScript. We can support this component if additional permissions are available. The system cpu permission provides information about the devices cpu such as the number of kernels, the name of the processor and whether the proessor uses additional suplementery instruction sets such as a streaming SIMD extension or a advanced vector extension. The system memory permission provides the capacity of the devices memory and the management permission can be used to get a list of installed extension and whether they are active of disabled.
Additionally to the common techniques to identify a web user, user tracking and fingerprinting, we have discovered another approach. As an extension can access any visited web page, we are able to collect personal user information which allows us to identify the person that uses the extension. We extracted three categories of worthwhile web applications that provide many usefull information. Sozial media, online banking and email clients. Many people use their real names and other personal information for their sozial media account. While the user uses his account, our implemented component collects these personal data and additionally collects information about his social and business environment by extracting personal data from other people the user interacts with. Another component that targets the user's online banking account collects his fincancial information such as account and credit card numbers and executed transactions. Finally we implemented components that read the users outgoing and incomming emails. 

Now that we have collected many usefull pieces of information to identify the current user, we have to transmit these information to the remote server that is in charge of the identification and then fetch the source code of our attack vectors. 
A simple way to communicate with a remote server is to use the XMLHttpRequest API to programatically execuet web requests. An extension needs matching host permissions otherwise the browser will block the request. As the URL of our remote server may change, we decided that our component needs host permission to all URLs. We can use this to send the collected user data to the remote server but also to fetch the source code of an attack vector. If we use this component to fetch the source code of an attack vector, the next step will be to execute the fetched code. If the source code has to be active in the scope of a web page, we can use the programatically injection to execute it as a content script. For that purpose we need host permissions that match the targeted web page's URL which we already have as we are using the XMLHttpRequest. If the source code has to be executed in the extension's background, we need a modified Content Security Policy in the extension's manifest to enable the use of eval. 
Another implemented component to communicate with a remote server uses the mechanics of an iframe in an arbritary web page. The iframe element allows to embed one web page in another. It has a source attribute that contains the URL of the targeted web page and loades the web page if the attribute changes. We set the URL of the iframe to the URL of our remote server and append the data that we want to transfer as URL parameters. The advantage of this component is that it only needs a content script in any web page and no host permissions. It is therefore more covert than the XMLHttpRequest approach because the host permissions indicate the extension's capability to execute requests to a remote server. We can also use this component to fetch the source code for an atack vector. If the remote server has embedded a script in the loaded web page, we extract it and either execute it directly in the scope of the targeted web page or transfer it to the background via the communication channel.
We implemented a thrid approach to fetch the source code for an attack vector that again takes use of the DOM. If we add a script element to the DOM and set its source attribute, the script will be fetched and executed. We can add a source element to the web page using a content script. However, if we want to add a source element to the background page, the default CSP denies it. Therefore, our component needs a modified CSP that allows to fetch scripts from remote origins. Unfortunally, the scope of applicaiton for this method is limited because it is not allowed to declare a URL pattern matching all web pages in the CSP. Wildcards are only allowed for subdomains.

Now we come to our implemented attack vectors. At this point, we have succesfully identified the current user and can now load the source code of an attack and execute it. First we want to show how simple it is to obtain sensitive information from a web page or modify its content. We have already presented some components that collect personal user data from sozial media, online banking and email clients. Now we present some more general approaches. To simplify the interaction with the DOM we use the popular library jquery. 
These small code examples show how simple it is to obtain sensitive data. In the first example, we first select all form elements on the current web page and then take use of JavaScript'S event-driven nature. We add an event listener that will be dispatched when the user submits the form. The listener extracts all values of the form and forwads them to our send method. We abstract the send method in thse examples because it depends on which communication component is currently active. In our second example we select an input field of type password and slelect the corresponding form element. This gives us the form that contains the user's credentials. We extract the values directly because we asume that the browser's password manager has filled in the credentials for the user. Of course, we can also use the first example for a login form. If we know where exactly sensitive information are stored inside a web page, we can extract them using a css selector. This allows us to obtain information that the web application currently displays for the user for example his credit card numbers.
It is also very simple to manipulate the content of a web page. These three examples show how we change the value of an input element which we identify by its name attribute, manipulate the target to which a form is send by setting its action attribute and how we exchange the target of an link element. 
Some of these attacks can be executed while the user navigates through the targete website. But we are also able to explicitly open web pages and executes attacks such as to steal probably stored credentials from the browser's password manager. For that purpose we implemented three components that follow different strategies. The first, loads the web page into an invisible iframe. This one is the least relyable one because there exists several approaches to enforce that a web page is not displayed into an iframe. The general approach is to use the X-Frame-Option HTTP header. If it is set the browser will actually prevent the loading of the web page. The second approach opens the targeted web page in an inactive tab. We use the browser API function chrome tabs query with the option active set to false which returns all tabs except the currently active one. We can then update one tab and load the targeted web page. After the attack has finished we load the original web page in order that the user does not notice the action. The third component can only work if the user has currently multiple brwoser windows open. Again we use the query function but this time we use the option current window set to false. Then we create a new tab in an not active window and close it after the attack has finished. 

The downloads module provides the functionality to initiate, cancel, and observer user downloads. We implemented three components that use this module. The first one downloads and opens a file on its own. This is probably our most threatening implementation because if we download some malware and execute it, we get access to the user's machine which we do not get using only an extension. We tested our implementation with a .xlsm file which is an excel sheet containing macros. Those macros can execute harmful behavior because they have full access to the operating system. 
The other two components exchange a file that the user currently downloads. The first component cancels a user download as soon as the user initiates it and executes the download of a harmful file with the same file name and mime type. The second component removes the user's downloaded file as soon as the downlaod has finished and initiates a new downlaod of a harmful file again with the same file name and mime type. Of course both components are only effective if the user does not notices the exchange of the file. 

We implemented further attack vectors such as to steal the user's cookies, disable other extensions, and to remove security relevant http header. Stored cookies often contain session cookies that authenticate the user against a web application on every web request. If we are able to obtain them, we can hijack the user's current session at the particular web application. A web page has access to stored cookies that belong the web page'S origin with the exception of cookies that have the http-only flag set. Those are not available for the web page's JavaScript and are often used for session cookies. We can collect all the others using a content script and to collect http-only cookies we use the extension's cookies module that allows to extract all currently stored cookies. To extract the cookies assoziated with a particular origin, the extension needs matching host permisions. 
We are able to silently disable other extensions using the management module. This allows us to disable extensions that provide security features and may hamper our other attack vectors.
The webRequest module allows to modify the http header of in and outgoing web requests. We use this feature to support our component that tries to open a particular web page in an iframe to execute another attack. As menioned earlier, this component is hampered by the X-Frame-Option HTTP header that disables the loadign of the web page into an iframe. Our component is able to remove this header from the request's response. Furthermore, we are able to remove other security relevant headers such as CSP and therefore support other components.
 
We analyzed the requested privileges of existing extensions to demonstrate that we are able to integrate our implemented components into them. For that purpose we fetched 15 extensions with a user count between a million and more than 10 million from Chrome's official web store. Among others, the popular extension AdBlock that has more than 10 million users. Furthermore, we categoriezed our implemented components to faciliate the analysis. We divided them into three groups. Group A contains all components that need access to a web page which means they have to be executed as a content script. This group contains most components from the identification section as they rely on collection user data from visited web pages. Group B contains all components that need host permissions to all web pages. As a host permission enables us to programatically execute a content script, all components from group A also belong to group B. Group C contains all other components that either need API permissions, a modified CSP or a combination of privileges. The bar chart below shows the amount of components in each group. Keep in mind that group B contains all components from group A, consequently only 2 components need exclusive host permissions. These two components execute programatically web requests to communicate with a remote server.
 
Now we present the general results of our analysis. We found 11 extensions that use a content script in all web pages and 12 extensions that declare host permission for all web pages. This allows us to execute all components from group A into 11 and all components from group B into 12 of the 15 analyzed extensions. If we calculate the union of both groups, we get 13 extensions that have access to all displayed web pages. Furthermore we focused on extensions that declare a modified CSP. We found 3 that allow the use of eval and 8 that allow the loading of remote script with script elements in the extension'S background. Both groups a very important for our system because eval and script elements are the only way to execute remotely loaded scripts in the extensions background. In all other extensions we are not able to execute attack vectors that have to be active in the extension's background. 
 
We found no extension that declares the downloads.open permission which is necessarry for our attack component that downloads and opens a harmful file. We still found two extensions that declare only the downloads permission and therefore allow us to integrate our attack components that exchange a downloaded file. We found the needed cookies permission for our component that collects all cookies in 9 extensions but only one permission declaring the management permission which our component to disable another extensions needs. Our component that supports other components by removing security relevant headers needs the webRequest and webRequestBlocking permissions and additionally host permissions to all web pages. We found 7 extensions matching these conditions. 

In conclusion we consider our system applicable to most popular extensions. The access to all displayed web pages that 13 of the 15 analyzed extensinos have, poses the biggest threat the user and his privacy and allows us to integrate the majority of our implemented components.

We will now present two approaches to counter malicious extensions that may also counter our implementations. 

The first approach is to detect malicious extensions. Researchers and security exports have developed several tools that range from a static analysis of an extension'S source code to find known malicious pattern up to a dynamic analysis of an extension's behavior in a sandboxed environment. Altough we designed our system to be difficult to detect because most of the malicious code is only present after a succesfull identification of the current user, we asume that some detection tools will still detect our malicous implementations. Especially if the analysis takes place while the user uses the browser 


A group of researchers analyzed the treats of Chrome extensions. As a countermeasure they proposed an improved permission system. Their first step was to create separate permissions for the extension's background and content script. Especially host permissions gave an extension several privileges at once. Therefore they diveded them into a list of web pages in which an extension is allowed to inject content scripts and a list of URLs to which an extension is allowed to execute web requests. The tabs permission in those lists gives access to the origin of the currently active tab. This would hamper our components that need access to a web page, because the extension needs explicit permissions for a programatically injection. Currently an extension is able to execute web requests without proper host permissions by adding new elements to the DOM of a web page such as iframes or images. If the elements source attribute changes the browser will execute a request to fetch the desired resource. We use this feature for a component that transfers collected user data to a remote server. To mitigate this threat, the researchers proposed a permission that restricts the origins that a content script can add to a web page. The last threat that the researcher address that we also see as the biggest threat for a user is the extension's unrestricted access to a web page. The researcher proposed a sensitivity level to identify elements that probably contain sensitive data and restrict the extensions access on those elements.